<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shuhan_Yao.Blog</title>
    <link>https://github.com/YaoShuHan/YaoShuHan.github.io/</link>
    <description>Recent content on Shuhan_Yao.Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 16 Sep 2017 13:47:14 +0800</lastBuildDate>
    
	<atom:link href="https://github.com/YaoShuHan/YaoShuHan.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MongoDB-基础</title>
      <link>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170916_mongodb/</link>
      <pubDate>Sat, 16 Sep 2017 13:47:14 +0800</pubDate>
      
      <guid>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170916_mongodb/</guid>
      <description>什么是MonogoDB MongoDB是由C++编写的，基于分布式文件存储的开源非关系型数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB将数据存储为一个文档，数据结构由键值对组成，其形式类似于JSON对象，字段值可以包含其它文档，数组和文档数组。
{ title: &amp;quot;MongoDB-基础&amp;quot;, trags: [&amp;quot;MongoDB&amp;quot;,&amp;quot;NoSQL&amp;quot;] }  NoSQL简介 NoSQL指的是非关系型的数据看。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称，用于超大规模数据的存储。
NoSQL
 高性能、高可用性、可伸缩性 分布式计算 低成本 架构灵活，半结构化数据（键值对存储，列存储，文档存储，图形数据库） 最终一致性，而非ACID属性 CAP定理  NoSQL数据库分类
   类型 部分代表 特点     列存储 Hbase Cassandra Hypertable 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。   文档存储 MongoDB CouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。   Key-Value存储 Tokyo Cabinet/Tyrant BerkeleyDB MemecacheDB Redis 可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）   图存储 Neo4J FlockDB 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。   对象存储 db4o Versant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。   xml数据库 BerkeleyDBXML BaseX 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。    MongoDB主要特点  MongoDB面向文档存储，操作起来比较简单和容易。 MongoDB可以设置任何属性的索引来实现更快的排序。 可以通过本地或者网络创建数据镜像，使得MongoDB有更强的扩展性。 如果负载的增加需要更多的存储空间和更强的处理能力，它可以分布在计算机网络中的其他节点上，即分片。 MongoDB支持丰富的查询表达式，查询指令使用JSON形式的标记。 MongoDB中内置GridFS，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本 支持多平台及多语言驱动  ACID</description>
    </item>
    
    <item>
      <title>初识golang—单例模式</title>
      <link>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170916_singleton_pattern/</link>
      <pubDate>Sat, 16 Sep 2017 11:36:57 +0800</pubDate>
      
      <guid>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170916_singleton_pattern/</guid>
      <description>单例模式是设计模式里最为常用的一种，应用该设计模式的目的是保证类仅有一个全局的对象实例。
懒汉模式(Lazy Loading) 懒汉模式是最为简单常见的，最大的缺点是非线程安全的。
type singleton struct { //... } //private var instance *singleton //public func GetInstance() *singleton { if instance == nil { instance = &amp;amp;singleton{} } return instance }  带锁的单例模式 sync包提供两种锁类型：Mutex和RWMutex。Mutex是我们常见的锁类型，当一个goroutine获得Mutex之后，其它的goroutine只能进行等待直到该Mutex被释放。而RWMutex则是较为友好的单读多写模型，写锁会阻止其它所任何goroutine访问，而读锁则只会阻止写而不阻止读。
这里使用了Go的sync.Mutex，解决了懒汉模式的线程安全问题，但是在已生成实例后每次访问还都会调用锁，造成不必要的开销。
type singleton sturct { } var instance *singleton var mu sync.Mutex func GetInstance() *singleton { mu.Lock() defer mu.Unlock() if instance == nil { instance = &amp;amp;singleton{} } return instance }  带检查锁的单例模式 通过再封加一层判断，可以解决不必要开销的问题。
if instance == nil { mu.</description>
    </item>
    
    <item>
      <title>更新OSX的Ruby版本</title>
      <link>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170909_ruby/</link>
      <pubDate>Sat, 09 Sep 2017 11:22:16 +0800</pubDate>
      
      <guid>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170909_ruby/</guid>
      <description> 在使用Homebrew安装工具时，返回了Ruby版本过低的RuntimeError。OSX是系统自带Ruby的，可以通过RVM(Ruby Version Manager)对其进行更新，RVM包含了Ruby的版本管理和Gem库管理(Gemset)。
安装RVM 1.下载安装RVM
$ curl -L get.rvm.io | bash -s stable  2.更新配置文件
$ source ~/.bashrc $ source ~/.bash_profile  3.验证是否安装成功
$ rvm -v  使用RVM升级Ruby 1.列出已知Ruby版本
$ rvm list  2.安装所需版本
$ rvm install 2.3.4  3.如果bash一片绿油油即成功，失败时执行
$ rvm reinstall 2.3.4  问题汇总 </description>
    </item>
    
    <item>
      <title>初识golang—并发基础</title>
      <link>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170908_golang/</link>
      <pubDate>Fri, 08 Sep 2017 20:51:36 +0800</pubDate>
      
      <guid>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170908_golang/</guid>
      <description>Golang是一个并发性极好的语言，通过goroutine和channel相配合，可以帮助我们轻松实现高并发服务端程序。
goroutine 相比于其它大部分语言通过库的方式支持协程，Go在语言级别支持协程，goroutine是Golang中对协程的实现，由Go的runtime管理。与传统的系统级进程和线程相比，协程最大的优势在于其“轻量级”，可以轻松创建上百万个而不必当心系统资源衰竭。 在Go中创建goroutine很简单，通过在函数调用前加上go关键字即可“ go func(&amp;hellip;) ”，在函数返回时这个goroutine也自动结束了，函数的返回值会被自动丢弃。
func loop(x int) { for i:=0; i &amp;lt; x; i++ fmt.Println(x) } func main(){ go loop(x) }  上面这段代码展示了go关键字的使用，但是会发现没有预期的运行效果。因为在goroutine并发执行时，主函数已经返回，它并不会等待goroutine的结束。 通过对主程序添加等待函数之类的阻塞主函数的结束来等待所有的协程执行完毕即可解决，但这种方式显然不够优雅。要如何知道goroutine都退出了又能阻塞主函数的结束呢？channel就是我们要找的答案。
channel 并发编程的一大难度是如何协调并发单元之间的通信，在C语言中，我们会为线程共享的数据加上锁(有时是好几层)，这使得逻辑与代码上变的臃肿。在将简洁与并发编程作为核心优势的Go中，提供了以信息机制提供数据共享支持的channel。
 &amp;ldquo;dont communicate by sharing memory, share memory by communicating&amp;rdquo;
 channel是Go在语言级别提供的goroutine间的通信方式，channel是进程内的通信，可以在多个goroutine之间传递信息，传递对象的行为和函数传参类似。channel是类型相关的，需要在声明channel时指定。channel的读写操作都是阻塞的，信道内空时才可写入，信道内有数据时才可读出，否则都将等待。
//channel的一般声明形式 var chanName chan ElementType //channel的一般定义形式 ch := make(chan int) //channel的写操作 ch &amp;lt;- value //channel的读操作 value := &amp;lt;-ch  通过channel我们可以将之前的代码进行改进
var ch chan string = make(chan string, 0) func loop(x int) { for i := 0; i &amp;lt; x; i++ { fmt.</description>
    </item>
    
    <item>
      <title>git版本控制</title>
      <link>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170830_git/</link>
      <pubDate>Wed, 30 Aug 2017 16:19:13 +0800</pubDate>
      
      <guid>https://github.com/YaoShuHan/YaoShuHan.github.io/blog/20170830_git/</guid>
      <description>Git简介 Git是一款免费、开源的分布式版本控制系统。
Linus在1991年创建了Linux内核开源项目，有着来自全世界的贡献者参与该项目，使其不断壮大发展。在早期(1991-2002)，绝大多数的Linux内核维护工作是由Linus本人通过手工方式进行合并与归档。直到2002年，随着代码库的逐渐壮大，Linus最终选择了启用BitMover的分布式版本控制系统BitKeeper，BitMover授权Linux社区免费使用。
到了2005年，由于社区内存在试图破解BitKeeper的协议被发现，所以BitMover收回了免费授权。于是，Linus Torvalds花了两周时间用C写了一个分布式版本控制系统&amp;ndash;Git，一个月内Linux社区的源码就由Git管理了，Git也迅速成为最流行的分布式版本控制系统！
Git的提交流程 Git和其他的版本控制系统如SVN的一个不同之处就是除了工作区、版本库之外还有暂存区的概念。
工作区(Working Directory)
工作区即本地项目目录。
版本库(Repository)
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
Git的版本库中有很多东西，包括称为stage(或者index)的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD。 在我们把文件往Git仓库里添加的时候，是分两步执行的：
 用git add把文件添加进去，实际上就是把文件修改添加到暂存区。 用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。  值得一提的是，Git追踪并管理的是修改而非文件，所以提交到仓库的是暂存区内的修改，而不是文件本身，而每个版本都是一份文件快照。
当我们执行如下过程：
 第一次修改 git add 第二次修改 git commit git status  会发现，git status的消息显示第二次的修改并没有被提交到仓库中。是由于git add只将第一次修改存入了暂存区，git commit只负责把暂存区的修改提交到仓库，所以第二次的修改没有在暂存区内也没有被提交。
再执行一次git add与git commit或在第一次git commit之前执行git add将第二次修改加入到暂存区，都可以达到将第二次修改提交的效果。
Git的分支管理 每次的版本提交，Git都会把它们串成一条条时间线，这些时间线就是一个个分支。其中有一条主分支master，在我们创建仓库时即存在。HEAD指针指向当前版本,在下图中HEAD指向master，即当前版本为master所在的节点。 Git中对分支的操作可以看作是对链表的操作。当我们创建新分支dev时，Git只需新建一个指针叫dev，指向上次提交，再把HEAD指向dev，就表示当前分支在dev上。 分支的合并可以看作一次提交。假如我们在dev上的工作完成了，就可以把dev合并到master上，相对于master来说合并的过程类似一次提交，同样也需要解决冲突，再将master指向dev当前提交就完成了合并。 合并完之后可以选择将dev分支删除，即将dev指针删掉。Git鼓励大量使用分支进行开发，在我们修正bug时可以新建bug分支，写实验性特性时可以新建feature分支，从而实现在不影响稳定版本的基础上进行开发。
远端仓库 Git作为分布式版本控制系统，同一个Git仓库可以通过克隆分布到不同的机器上。在实际的生产中，通常会找一台电脑或者像github(在线Git仓库托管服务平台)充当Git仓库服务器。
本地仓库与github仓库的通信通常通过SSH或http传输。配置SSH时需在shell或git bash中使用$ ssh-keygen -t rsa -C &amp;quot;email@example.com&amp;quot;，将在用户主目录的.ssh中生成密钥对(id_rsa和id_rsa.pub)，然后github中打开SSH Keys页面将id_rsa.pub的内容加入到其中。
Git操作 配置Git # 配置用户名与邮箱 $ git config --global user.name &amp;quot;My Name&amp;quot; $ git config --global user.</description>
    </item>
    
    <item>
      <title>Second</title>
      <link>https://github.com/YaoShuHan/YaoShuHan.github.io/photo/second/</link>
      <pubDate>Thu, 13 Jul 2017 11:22:16 +0800</pubDate>
      
      <guid>https://github.com/YaoShuHan/YaoShuHan.github.io/photo/second/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>